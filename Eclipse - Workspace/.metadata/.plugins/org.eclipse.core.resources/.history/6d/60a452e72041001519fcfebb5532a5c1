package proj_dist;

import java.util.ArrayList;
import java.util.Random;

public class Algoritmo_Distribuido {
	
	// Constantes
	private static int QUANT_MAX_NIVEL = 3;

	// Variáveis
	private ArrayList<Vertice> vertices;
	private int numTotalVertices;
	private double raio;
	private double areaTotal;
	private boolean comDilution;
	private double ladoArea;
	private double alcanceSensor;
	private int quantCoresUtilizadas;
	
	// Construtor
	public Algoritmo_Distribuido(int numTotalVertices, double raio, double areaTotal, boolean comDilution){
		setNumTotalVertices(numTotalVertices);
		setRaio(raio);
		setAreaTotal(areaTotal);
		setComDilution(comDilution);
		
		calculaValoresSemComDilution();
		vertices = new ArrayList<Vertice>();
	}

	// Método para inicializar variáveis sem / com Dilution
	private void calculaValoresSemComDilution(){
		ladoArea = Math.sqrt(areaTotal);
		
		if(isComDilution())
			alcanceSensor = raio * Math.sqrt(2);
		else
			alcanceSensor = raio;
	}
	
	/**
	 * Método para a lista de vértices.
	 */
	public void inicializaVertices(){
		Random random = new Random();
		for(int id = 0; id < getNumTotalVertices(); id++){
			double posicaoX = (random.nextDouble() * getLadoArea());
			double posicaoY = (random.nextDouble() * getLadoArea());
			boolean achou = false;
			while(!achou){
				// Procura por vértices que estejam nas mesmas posições
				for (int v = 0; v < vertices.size() && !achou; v++) {
					if(posicaoX == vertices.get(v).getPosicaoX() && posicaoY == vertices.get(v).getPosicaoY())
						achou = true;
				}
				
				// Se achar determina uma nova e analisa-se novamente
				if(achou){
					posicaoX = (random.nextDouble() * getLadoArea());
					posicaoY = (random.nextDouble() * getLadoArea());
					achou = false;
				} else
					achou = true;
			}
			vertices.add(id, new Vertice(id, posicaoX, posicaoY));
		}
		
		// Obter a lista de distâncias
		for(Vertice v : vertices){
			ArrayList<Distancia> d = retornaListaDistancias(v); 
			System.out.println(d.get(0).getVertice() + " - " + d.get(0).getDistancia());
			v.setDistancias(d);
		}
	}
	
	public ArrayList<Distancia> retornaListaDistancias(Vertice vertice){
		ArrayList<Distancia> distancia = new ArrayList<Distancia>();
		for(Vertice v : vertices){
			if(v.getIdentificador() != vertice.getIdentificador()){
				double dist = Math.sqrt(
						Math.pow((vertice.getPosicaoX() - v.getPosicaoX()), 2) +
						Math.pow((vertice.getPosicaoY() - v.getPosicaoY()), 2)
				);
				
				if(dist <= getAlcanceSensor()){
					//System.out.println("Vertice " + vertice.getIdentificador() + ": " + v.getIdentificador() + " - " + dist);
					distancia.add(new Distancia(v.getIdentificador(), dist));
				}
			}
		}
		return distancia;
	}
	
	/*
	private ArrayList<Integer> retornaPosicaoVizinhosAte3Saltos(int quantVizinhosTotal, int quantVizinhosAtual, ArrayList<Integer> posicaoVerticesVisitados, int posicaoVerticeAtual, boolean pararSalto, byte nivel, Vertice[] vertices){
		// O processamento recursivo irá parar quando os vizinhos dos vizinhos do seu
		// último vizinho forem visitados.
		if(quantVizinhosAtual == quantVizinhosTotal){
			// Remove o vértice desejado da lista de vértices visitados
			if(nivel == 0){
				posicaoVerticesVisitados.remove(0);
			}
		} else {
			// Se um vértice não está contido na lista, deve-se incluí-lo
			if(!posicaoVerticesVisitados.contains(posicaoVerticeAtual)){
				posicaoVerticesVisitados.add(posicaoVerticeAtual);
			}
			
			// Determina se deve realizar um salto ou não
			pararSalto = (nivel == QUANT_MAX_NIVEL) ? true : false;
			
			// Caso deva-se realizar um salto, serão visitados os vizinhos dos vizinhos dos vizinhos do vértice em questão
			if(!pararSalto){
				int idNovoAtual = retornaVizinhosUmSalto(vertices[posicaoVerticeAtual]).get(quantVizinhosAtual).getOrdemListaPriori();
				int novoTotal = retornaVizinhosUmSalto(vertices[idNovoAtual]).size();
				nivel++;
				retornaPosicaoListaPrioriVizinhosAte3Saltos(novoTotal, 0, posicaoVerticesVisitados, idNovoAtual, pararSalto, nivel, vertices);
				nivel--;
				quantVizinhosAtual++;
				retornaPosicaoListaPrioriVizinhosAte3Saltos(quantVizinhosTotal, quantVizinhosAtual, posicaoVerticesVisitados, posicaoVerticeAtual, pararSalto, nivel, vertices);
			}
		}
		return posicaoVerticesVisitados;
	}
	*/
	
	/*
	private int retornaPrioridadeVertice(int quantVizinhosTotal, int quantVizinhosAtual, ArrayList<Integer> idVerticesVisitados, Vertice verticeAtual, boolean pararSalto, byte nivel){
		// O processamento recursivo irá parar quando os vizinhos dos vizinhos do seu
		// último vizinho forem visitados.
		if(quantVizinhosAtual == quantVizinhosTotal){
			// Remove o vértice desejado da lista de vértices visitados
			if(nivel == 0){
				idVerticesVisitados.remove(0);
			}
		} else {
			// Se um vértice não está contido na lista, deve-se incluí-lo
			if(!idVerticesVisitados.contains(verticeAtual.getIdentificador())){
				idVerticesVisitados.add(verticeAtual.getIdentificador());
			}
			
			// Determina se deve realizar um salto ou não
			pararSalto = (nivel == QUANT_MAX_NIVEL) ? true : false;
			
			// Caso deva-se realizar um salto, serão visitados os vizinhos dos vizinhos dos vizinhos do vértice em questão
			if(!pararSalto){
				Vertice novoAtual = retornaVizinhosUmSalto(verticeAtual).get(quantVizinhosAtual);
				int novoTotal = retornaVizinhosUmSalto(novoAtual).size();
				nivel++;
				retornaPrioridadeVertice(novoTotal, 0, idVerticesVisitados, novoAtual, pararSalto, nivel);
				nivel--;
				quantVizinhosAtual++;
				retornaPrioridadeVertice(quantVizinhosTotal, quantVizinhosAtual, idVerticesVisitados, verticeAtual, pararSalto, nivel);
			}
		}
		return idVerticesVisitados.size();
	}
	
	private Vertice[] transformaGridEmVetorOrdenadoPriori(){
		
		// Cria um vetor com a quantidade de vértices do grid
		Vertice[] retorno = new Vertice[grid.length * grid.length];
		
		// Atribui cada a posição do vetor um vértice do grid 
		int posicao = 0;
		for(int linha = 0; linha < grid.length; linha++)
			for(int coluna = 0; coluna < grid.length; coluna++)
				retorno[posicao++] = grid[linha][coluna];
		
		// Ordena o vetor
		Utilidade.ordenaListaVertices(retorno, 0, retorno.length - 1);
		
		// Atribui a cada vértice, a sua posição na lista de prioridades
		for(posicao = 0; posicao < retorno.length; posicao++){
			retorno[posicao].setOrdemListaPriori(posicao);
		}
		
		return retorno;
	}
		
	public void coloreGridTresSaltosComBasePrioridades() {
		Vertice[] vetorVerticesOrdPriori = transformaGridEmVetorOrdenadoPriori();
		
		// Variável que indica se podemos ou não colorir o vértice com certa cor
		boolean colorir = true;

		// Vértice com maior prioridade que não foi colorido, deve-se colorir com a cor 1
		int cor = 1;
		if(vetorVerticesOrdPriori[0].getCor() == -1) {
			vetorVerticesOrdPriori[0].setCor(cor++);
		}
		
		// Lista dos vizinhos
		ArrayList<Integer> vizinhos = new ArrayList<Integer>();

		// para cada vértice do grid, procurar a cor para colorí-lo
		for (int vertice = 1; vertice < vetorVerticesOrdPriori.length; vertice++) {
			
			// Pega os vizinhos do vértice em questão
			vizinhos = (isComDilution()) ?
				retornaPosicaoListaPrioriVizinhosAte3Saltos(vetorVerticesOrdPriori[vertice]) :
				retornaPosicaoListaPrioriVizinhosAte3Saltos(retornaVizinhosUmSalto(vetorVerticesOrdPriori[vertice]).size(), 0, new ArrayList<Integer>(), vetorVerticesOrdPriori[vertice].getOrdemListaPriori(), false, (byte) 0, vetorVerticesOrdPriori);
			
			int corAtual = 1;
			
			// Variável booleana que indica se o vértice foi colorido
			boolean flag = false;
			while(flag == false && corAtual <= cor) {
				colorir = true;
				
				// Analisa se a cor dos vizinhos é igual a corAtual 
				int cont = 0;
				while(cont < vizinhos.size() && colorir == true){
					// Ver a cor do vizinho
					if (vetorVerticesOrdPriori[vizinhos.get(cont)].getCor() == corAtual)
						// Se a cor já utilizada pelo vizinho, então não pode utilizar esta cor
						colorir = false;
					cont++;
				}
				
				// Colore o vértice quando colorir é igual a true
				if (colorir == true) {
					
					// Analisar os possíveis vértices mais próximos, os quais devem ter a mesma cor
					ArrayList<Integer> verticesMesmaCor = retornaPosicaoListaPrioriVerticesComMesmaCor(vetorVerticesOrdPriori[vertice]);
					cont = 0;
					// Se existe um padrão de cores, então colore-se o vértice com a cor do padrão
					while(cont < verticesMesmaCor.size() && flag == false){
						if(vetorVerticesOrdPriori[verticesMesmaCor.get(cont)].getCor() != -1){
							vetorVerticesOrdPriori[vertice].setCor(vetorVerticesOrdPriori[verticesMesmaCor.get(cont)].getCor());
							// Indica que o vértice foi colorido
							flag = true;
						}
						cont++;
					}
					
					// Se o vértice não foi colorido, então colore-o com a cor atual
					if(flag == false){
						vetorVerticesOrdPriori[vertice].setCor(corAtual);
						flag = true;
					}
				}
				corAtual++;
			}
			
			// Se não pode colorir o vértice com uma cor, colore-o com a próxima cor
			if (colorir == false) {
				cor++;
				vetorVerticesOrdPriori[vertice].setCor(cor);
			}
		}
		
		// Armazenando a quantidade de cores utilizada
		quantCoresUtilizadas = cor;
	}
	*/
	
	/**
	 * Método para mostrar os ids dos vértices.
	 */
	public void mostraId(){
		System.out.println("Visualização dos Vértices por Id");
		for (Vertice vertice : vertices) {
			System.out.println(vertice.getIdentificador());
		}
	}
	
	/**
	 * Método para mostrar os ids e posições dos vértices.
	 */
	public void mostraIdPosicoes(){
		System.out.println("Visualização dos Vértices por Id e Posição");
		for (Vertice vertice : vertices) {
			System.out.println(vertice.getIdentificador() + " - " +
					vertice.getPosicaoX() + " - " + vertice.getPosicaoY()
			);
		}
	}
	
	/**
	 * Método para mostrar as cores dos vértices.
	 */
	public void mostraCor(){
		System.out.println("Visualização dos Vértices por Cor");
		for (Vertice vertice : vertices) {
			System.out.println(vertice.getIdentificador() + " - " + vertice.getCor());
		}
	}
	
	/**
	 * Método toString, o qual retorna uma string com as informações dos atributos.
	 * 
	 * @return String - Sequência de caracteres contendo as informações dos atributos.
	 */
	@Override
	public String toString(){
		return "Lado da Área: " + getLadoArea() + "\nÁrea total: " + getAreaTotal() +
				"\nAlcance do Sensor: " + getAlcanceSensor() + "\nNúmero Total de Vértices: " + getNumTotalVertices() +
				"\nRaio: " + getRaio() + "\nQuantidade de Cores Utilizadas: " + getQuantCoresUtilizadas();
	}

	// Métodos Getters e Setters

	public double getAreaTotal() {
		return areaTotal;
	}

	public void setAreaTotal(double areaTotal) {
		this.areaTotal = areaTotal;
	}

	public double getRaio() {
		return raio;
	}

	public void setRaio(double raio) {
		this.raio = raio;
	}

	public int getNumTotalVertices() {
		return numTotalVertices;
	}

	public void setNumTotalVertices(int numTotalVertices) {
		this.numTotalVertices = numTotalVertices;
	}

	public boolean isComDilution() {
		return comDilution;
	}

	public void setComDilution(boolean comDilution) {
		this.comDilution = comDilution;
	}

	public ArrayList<Vertice> getVertices() {
		return vertices;
	}

	public double getLadoArea() {
		return ladoArea;
	}

	public double getAlcanceSensor() {
		return alcanceSensor;
	}

	public int getQuantCoresUtilizadas() {
		return quantCoresUtilizadas;
	}
}