package execucao;

import java.util.HashMap;
import javax.swing.JOptionPane;
import br.ufs.dsi.redes_sensores.project.*;

public class Execucao {
	
	public static enum tipo_metodo { TIPO_1, TIPO_2 };
	
	/**
	 * Método main para executar os projetos.
	 */
	public static void main(String[] args) {
		int tipo;
		do {
			tipo = Integer.parseInt(JOptionPane.showInputDialog(null,
					"Informe o tipo do projeto:\n" +
					"1- Coloração com Cálculo de Prioridade\n" +
					"2- Coloração por Método Vetor\n" + 
					"0 - Encerrar o programa", "Entrada", JOptionPane.QUESTION_MESSAGE));
		} while(tipo < 0 && tipo > 2);
		
		if(tipo != 0){
			// True: Método Vetor | False: Coloração Baseada em Prioridades
			boolean eMetodoVetor = (--tipo == tipo_metodo.TIPO_2.ordinal());
			int dimensaoGrid = Integer.parseInt(JOptionPane.showInputDialog(null, "Entre com os valores da área (M) x (M)", "Entrada", JOptionPane.QUESTION_MESSAGE));
			double ladoQuadrado = Double.parseDouble(JOptionPane.showInputDialog(null, "Entre com o valor do lado quadrado do grid \n (Use o ponto como separador de casas decimais)", "Entrada", JOptionPane.QUESTION_MESSAGE));
			int simOuNao = JOptionPane.showConfirmDialog(null, "Deseja executar o projeto com Dilution?", "Entrada", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
			boolean comDilution = (simOuNao == JOptionPane.YES_OPTION) ? true : false;
			
			Grid grid = new Grid(ladoQuadrado, dimensaoGrid, comDilution, eMetodoVetor);
			
			// Inicializa o grid com os vértices
			grid.inicializaVertices();
			
			// Mostra o grid pelos identificadores
			grid.mostraGrigId();
			System.out.println();
			
			// Mostra o grid pelas prioridades
			if(!grid.isMetodoVetor()){
				grid.mostraGrigPriori();
				System.out.println();
			}
			
			// Variável para determinar o tempo para colorir o grid (tempo em milisegundos)
			long tempo = System.currentTimeMillis();
			
			// Colore o grid
			if(!grid.isMetodoVetor())
				grid.coloreGridTresSaltosComBasePrioridades();
			else
				grid.coloreGridTresSaltosMetodoVetor();
			
			// Tempo Total = Tempo Final - Tempo Inicial
			tempo = System.currentTimeMillis() - tempo;
			System.out.println("Tempo de Processamento em milisegundos: " + tempo);
			System.out.println();
			
			// Mostra o grid pelas cores
			grid.mostraGrigCor();
			
			// Mostra informações do grid
			System.out.println();
			System.out.println(grid.toString());
			
			// Verificando os vizinhos de um determinado vértice
			int linha = Integer.parseInt(JOptionPane.showInputDialog(null, "Entre com o valor da linha do vértice (1 - " + grid.getNumParcialVertices() + ")", "Entrada", JOptionPane.QUESTION_MESSAGE));
			int coluna = Integer.parseInt(JOptionPane.showInputDialog(null, "Entre com o valor da coluna do vértice (1 - " + grid.getNumParcialVertices() + ")", "Entrada", JOptionPane.QUESTION_MESSAGE));
			Vertice vertice = grid.getGrid()[--linha][--coluna];
			
			System.out.println("\nVizinhos do vértice " + vertice.getIdentificador() + ":\n");
			System.out.println("Vizinho\t\tSalto");
			HashMap<Vertice, Integer> vizinhos = grid.retornaVizinhosNSalto(vertice, 3);
			for (Vertice v : vizinhos.keySet()) {
				System.out.println(v.getIdentificador() + "\t\t" + vizinhos.get(v));
			}
		}
	}
}