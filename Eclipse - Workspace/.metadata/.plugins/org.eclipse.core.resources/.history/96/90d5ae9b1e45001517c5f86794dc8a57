package negocio;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

import model.Distancia;
import model.VerticeDist;
import utils.Utilidade;

public class Algoritmo_Distribuido {

	// Variáveis
	private ArrayList<VerticeDist> vertices;
	private int numTotalVertices;
	private double raio;
	private double areaTotal;
	private boolean comDilution;
	private double ladoArea;
	private double alcanceSensor;
	private int quantCoresUtilizadas;
	
	// Construtor
	public Algoritmo_Distribuido(int numTotalVertices, double raio, double areaTotal, boolean comDilution){
		setNumTotalVertices(numTotalVertices);
		setRaio(raio);
		setAreaTotal(areaTotal);
		setComDilution(comDilution);
		
		calculaValoresSemComDilution();
		vertices = new ArrayList<VerticeDist>();
	}

	// Método para inicializar variáveis sem / com Dilution
	private void calculaValoresSemComDilution(){
		ladoArea = Math.sqrt(areaTotal);
		
		// TODO: Corrigir isso com base no dilution.
		/*
		 if(isComDilution())
			alcanceSensor = raio * Math.sqrt(2);
		else
			alcanceSensor = raio;
		*/
		
		alcanceSensor = raio;
	}
	
	/**
	 * Método para iniciar a lista de vértices, bem como determina a prioridade de cada vértice
	 * e seus vizinhos de um salto com base no alcance do sensor.
	 */
	public void inicializaVertices(){
		Random random = new Random();
		for(int id = 0; id < getNumTotalVertices(); id++){
			
			// Determina aleatoriamente as posições
			double posicaoX = (random.nextDouble() * getLadoArea());
			double posicaoY = (random.nextDouble() * getLadoArea());
			
			// Determina um posição única no plano
			boolean achou = false;
			while(!achou){
				// Procura por vértices que estejam nas mesmas posições
				for (int v = 0; v < vertices.size() && !achou; v++) {
					if(posicaoX == vertices.get(v).getPosicaoX() && posicaoY == vertices.get(v).getPosicaoY())
						achou = true;
				}
				
				// Se achar, determina uma nova e analisa-se novamente
				if(achou){
					posicaoX = (random.nextDouble() * getLadoArea());
					posicaoY = (random.nextDouble() * getLadoArea());
					achou = false;
				} else
					achou = true;
			}
			
			// Cria um vértice e adiciona-o na lista
			vertices.add(new VerticeDist(id, posicaoX, posicaoY));
		}
		
		// Determina os vizinhos de um salto de cada vértice e calcula-se a sua prioridade
		determinaPrioridade();
	}
	
	/**
	 * Método que determina a prioridade de cada vértice, assim como a lista de vizinhos
	 * de um salto.
	 */
	private void determinaPrioridade(){
		// Obtém a lista de distâncias dos vizinhos de um salto de cada vértice
		for(VerticeDist v : vertices){
			v.setVizinhos(retornaListaDistancias(v.getIdentificador()));
		}
		
		// Calcular a prioridade de cada vértice
		for(VerticeDist v : vertices){
			v.setPrioridade(retornaPrioridadeVertice(v.getIdentificador()));
		}
	}
	
	/**
	 * Método que calcula a Distância Euclidiana entre um determinado vértice e
	 * os demais vértices, bem como adiciona na lista de vizinhos apenas os
	 * identificadores dos vértices que estão ao seu alcance.
	 * 
	 * @param vertice: Identificador do Vértice.
	 * 
	 * @return HashMap<Integer, Double> : Lista de identificadores e distância dos vizinhos de
	 * um salto.
	 */
	private HashMap<Integer, Double> retornaListaDistancias(int vertice){
		HashMap<Integer, Double> vizinhos = new HashMap<Integer, Double>();
		
		// Analisa-se todos os vértices, exceto o vértice passado como parâmetro
		for(VerticeDist v : vertices){
			if(v.getIdentificador() != vertices.get(vertice).getIdentificador()){
				// Cálculo da Distância Euclidiana
				double dist = Math.sqrt(
						Math.pow((vertices.get(vertice).getPosicaoX() - v.getPosicaoX()), 2) +
						Math.pow((vertices.get(vertice).getPosicaoY() - v.getPosicaoY()), 2)
				);
				
				// Se estiver dentro do alcance do sensor, então é vizinho de um salto
				if(dist <= getAlcanceSensor()){
					vizinhos.put(v.getIdentificador(), dist);
				}
			}
		}
		return vizinhos;
	}
	
	/**
	 * Método que retorna uma lista com os identificadores dos vizinhos dos vizinhos
	 * dos vizinhos de um salto de um vértice.
	 * 
	 * @param quantVizinhosTotal - Quantidade de vizinhos de um salto de um vértice.
	 * @param quantVizinhosAtual - Quantidade de vizinhos de um salto analisados.
	 * @param idVerticesVisitados - Lista com os identificadores dos vizinhos
	 * que foram visitados.
	 * @param vertice - Identificador do vértice a ser analisado. 
	 * @param pararSalto - Variável booleana que indica se deve realizar mais um salto ou não.
	 * @param nivel - Número do Salto. Seu valor vai até 3 saltos.
	 * @param numSaltos - Número de Saltos desejados.
	 * 
	 * @return ArrayList - Lista com os identificadores dos vizinhos que foram visitados.
	 */
	private ArrayList<Integer> retornaIdVizinhosNSaltos(int quantVizinhosTotal, int quantVizinhosAtual, ArrayList<Integer> idVerticesVisitados, int vertice, boolean pararSalto, byte nivel, byte numSaltos){
		/* O processamento recursivo irá parar quando os vizinhos dos vizinhos do seu
		   último vizinho forem visitados.
		*/
		if(quantVizinhosAtual == quantVizinhosTotal){
			// Remove o vértice desejado da lista de vértices visitados
			if(nivel == 0){
				if(idVerticesVisitados.size() > 0)
					idVerticesVisitados.remove(0);
			}
		} else {
			// Se um vértice não está contido na lista, deve-se incluí-lo
			if(!idVerticesVisitados.contains(vertice)){
				idVerticesVisitados.add(vertice);
			}
			
			// Determina se deve realizar um salto ou não
			pararSalto = (nivel == numSaltos) ? true : false;
			
			// Caso deva-se realizar um salto, serão visitados os vizinhos dos vizinhos dos vizinhos do vértice em questão
			if(!pararSalto){
				
				int idNovoAtual = new ArrayList<Integer>(vertices.get(vertice).getVizinhos().keySet()).get(quantVizinhosAtual);
				int novoTotal = vertices.get(idNovoAtual).getVizinhos().size();
				nivel++;
				retornaIdVizinhosNSaltos(novoTotal, 0, idVerticesVisitados, idNovoAtual, pararSalto, nivel, numSaltos);
				nivel--;
				quantVizinhosAtual++;
				retornaIdVizinhosNSaltos(quantVizinhosTotal, quantVizinhosAtual, idVerticesVisitados, vertice, pararSalto, nivel, numSaltos);
			}
		}
		return idVerticesVisitados;
	}
	
	/**
	 * Método que calcula a prioridade de um vértice.
	 * 
	 * @param vertice - Vértice qualquer da lista, o qual será calculado a prioridade do mesmo.
	 * 
	 * @return Integer - Prioridade do vértice.
	 */
	private int retornaPrioridadeVertice(int vertice){
		ArrayList<Integer> idVerticesVisitados = new ArrayList<Integer>();
		retornaIdVizinhosNSaltos(vertices.get(vertice).getVizinhos().size(), 0, idVerticesVisitados, vertice, false, (byte) 0, (byte) 3);
		return idVerticesVisitados.size();
	}
	
	/**
	 * Método que retorna uma lista com os identificadores dos vizinhos de
	 * dois ou três saltos de um vértice.
	 * 
	 * @param vertice - Vértice qualquer da lista, o qual será calculado a prioridade do mesmo.
	 * @param numSaltos - Número de Saltos (2 ou 3).
	 * 
	 * @return ArrayList - Lista com os identificadores dos vizinhos que foram visitados.
	 */
	private ArrayList<Integer> retornaVizinhosDoisOuTresSaltos(int vertice, byte numSaltos){
		// Obtendo os vizinhos de até 'numSaltos' saltos
		ArrayList<Integer> idVerticesVisitados = new ArrayList<Integer>();
		retornaIdVizinhosNSaltos(vertices.get(vertice).getVizinhos().size(), 0, idVerticesVisitados, vertice, false, (byte) 0, numSaltos);
		
		// Removendo os vizinhos de um salto
		for(Distancia d1 : vertices.get(vertice).getDistancias()){
			
			int vizinho = -1;
			if(idVerticesVisitados.contains(d1.getVertice())){
				
				// Removendo os vizinhos de dois salto
				if(numSaltos == 3){
					for(Distancia d2 : vertices.get(d1.getVertice()).getDistancias()){
						if(idVerticesVisitados.contains(d2.getVertice())){
							vizinho = idVerticesVisitados.indexOf(d2.getVertice());
							idVerticesVisitados.remove(vizinho);
						}
					}
				}
				vizinho = idVerticesVisitados.indexOf(d1.getVertice());
				idVerticesVisitados.remove(vizinho);
			}
		}
		
		return idVerticesVisitados;
	}
	
	/**
	 * Método que transforma uma lista de vértices em um vetor ordenado em ordem
	 * decrescente pela prioridade e crescente pelo identificador.
	 * 
	 * @return VerticeDist[] - um vetor de vértices ordenado em ordem decrescente pela
	 * prioridade e crescente pelo identificador.
	 */
	private VerticeDist[] transformaListaVerticesEmVetorOrdenadoPriori(){
		// Cria um vetor com a quantidade de vértices
		VerticeDist[] retorno = new VerticeDist[vertices.size()];
		
		// Transforma a lista em um vetor
		retorno = vertices.toArray(retorno);		
		
		// Ordena o vetor
		Utilidade.ordenaListaVertices(retorno, 0, retorno.length - 1);
		
		// Atribui-se a posição do vértice no vetor no próprio vértice 
		for(int posicao = 0; posicao < retorno.length; posicao++){
			retorno[posicao].setOrdemListaPriori(posicao);
		}
		
		return retorno;
	}
	
	/**
	 * Método que permite colorir os vértices com coloração de três saltos.
	 */
	public void coloreTresSaltosComBasePrioridades() {
		VerticeDist[] vetorVerticesOrdPriori = transformaListaVerticesEmVetorOrdenadoPriori();
		
		// Variável que indica se podemos ou não colorir o vértice com certa cor
		boolean colorir = true;

		// Vértice com maior prioridade que não foi colorido, deve-se colorir com a cor 1
		int cor = 1;
		if(vetorVerticesOrdPriori[0].getCor() == -1) {
			vetorVerticesOrdPriori[0].setCor(cor++);
		}
		
		// Lista dos vizinhos
		ArrayList<Integer> vizinhos = new ArrayList<Integer>();

		// para cada vértice, procurar a cor para colorí-lo
		for (int vertice = 1; vertice < vetorVerticesOrdPriori.length; vertice++) {
			
			// Pega os vizinhos do vértice em questão
			// TODO: Ver a questão do dilution nos vizinhos
			vizinhos = retornaIdVizinhosNSaltos(vetorVerticesOrdPriori[vertice].getDistancias().size(), 0, new ArrayList<Integer>(), vetorVerticesOrdPriori[vertice].getIdentificador(), false, (byte) 0, (byte) 3);
			
			int corAtual = 1;
			
			while(corAtual <= cor) {
				colorir = true;
				
				// Analisa se a cor dos vizinhos é igual a corAtual 
				int cont = 0;
				while(cont < vizinhos.size() && colorir == true){
					// Ver a cor do vizinho
					if (vertices.get(vizinhos.get(cont)).getCor() == corAtual)
						// Se a cor já utilizada pelo vizinho, então não pode utilizar esta cor
						colorir = false;
					cont++;
				}
				
				// Colore o vértice quando colorir é igual a true
				if (colorir == true) {
					vetorVerticesOrdPriori[vertice].setCor(corAtual);
					break;
				}
				
				corAtual++;
			}
			
			// Se não pode colorir o vértice com uma cor, colore-o com a próxima cor
			if (colorir == false) {
				cor++;
				vetorVerticesOrdPriori[vertice].setCor(cor);
			}
		}
		
		// Armazenando a quantidade de cores utilizada
		quantCoresUtilizadas = cor;
	}
	
	/**
	 * Método para mostrar os ids dos vértices.
	 */
	public void mostraId(){
		System.out.println("Visualização dos Vértices por Id");
		for (VerticeDist vertice : vertices) {
			System.out.println(vertice.getIdentificador());
		}
	}
	
	/**
	 * Método para mostrar os ids e posições dos vértices.
	 */
	public void mostraIdPosicoes(){
		System.out.println("Visualização dos Vértices por Id e Posição");
		System.out.println("Id\t\tPosição X\t\t\tPosição Y");
		for (VerticeDist vertice : vertices) {
			System.out.println(vertice.getIdentificador() + "\t\t" +
					vertice.getPosicaoX() + "\t\t" + vertice.getPosicaoY()
			);
		}
	}
	
	/**
	 * Método para mostrar as prioridades dos vértices.
	 */
	public void mostraPrioridades(){
		System.out.println("Visualização dos Vértices por Prioridade");
		System.out.println("Id\t\tPrioridade");
		for (VerticeDist vertice : vertices) {
			System.out.println(vertice.getIdentificador() + "\t\t" + vertice.getPrioridade());
		}
	}
	
	/**
	 * Método para mostrar as cores dos vértices.
	 */
	public void mostraCor(){
		System.out.println("Visualização dos Vértices por Cor");
		System.out.println("Id\t\tCor");
		for (VerticeDist vertice : vertices) {
			System.out.println(vertice.getIdentificador() + "\t\t" + vertice.getCor());
		}
	}
	
	/**
	 * Método para mostrar os vértices e seus vizinhos de um salto.
	 */
	public void mostraVerticesComVizinhosUmSalto(){
		System.out.println("Visualização dos Vértices com Seus Vizinhos de 1 Salto");
		for (VerticeDist vertice : vertices) {
			System.out.println("\nVértice " + vertice.getIdentificador() + ":");
			if(vertice.getDistancias().size() > 0){
				for(Distancia distancia : vertice.getDistancias()){
					System.out.print(distancia.getVertice() + "\t");
				}
			} else {
				System.out.print("NULL");
			}
			System.out.println();
		}
	}
	
	/**
	 * Método para mostrar os vértices e seus vizinhos de dois ou três saltos.
	 */
	public void mostraVerticesComVizinhosDoisOuTresSaltos(byte numSaltos){
		System.out.println("Visualização dos Vértices com Seus Vizinhos de " + numSaltos + " Saltos");
		for (VerticeDist vertice : vertices) {
			System.out.println("\nVértice " + vertice.getIdentificador() + ":");
			ArrayList<Integer> vizinhos = retornaVizinhosDoisOuTresSaltos(vertice.getIdentificador(), numSaltos);
			if(vizinhos.size() > 0){
				for(int id : vizinhos){
					System.out.print(id + "\t");
				}
			} else {
				System.out.print("NULL");
			}
			System.out.println();
		}
	}
	
	/**
	 * Método toString, o qual retorna uma string com as informações dos atributos.
	 * 
	 * @return String - Sequência de caracteres contendo as informações dos atributos.
	 */
	@Override
	public String toString(){
		return "Lado da Área: " + getLadoArea() + "\nÁrea total: " + getAreaTotal() +
				"\nAlcance do Sensor: " + getAlcanceSensor() + "\nNúmero Total de Vértices: " + getNumTotalVertices() +
				"\nRaio: " + getRaio() + "\nQuantidade de Cores Utilizadas: " + getQuantCoresUtilizadas();
	}

	// Métodos Getters e Setters

	public double getAreaTotal() {
		return areaTotal;
	}

	public void setAreaTotal(double areaTotal) {
		this.areaTotal = areaTotal;
	}

	public double getRaio() {
		return raio;
	}

	public void setRaio(double raio) {
		this.raio = raio;
	}

	public int getNumTotalVertices() {
		return numTotalVertices;
	}

	public void setNumTotalVertices(int numTotalVertices) {
		this.numTotalVertices = numTotalVertices;
	}

	public boolean isComDilution() {
		return comDilution;
	}

	public void setComDilution(boolean comDilution) {
		this.comDilution = comDilution;
	}

	public ArrayList<VerticeDist> getVertices() {
		return vertices;
	}

	public double getLadoArea() {
		return ladoArea;
	}

	public double getAlcanceSensor() {
		return alcanceSensor;
	}

	public int getQuantCoresUtilizadas() {
		return quantCoresUtilizadas;
	}
}